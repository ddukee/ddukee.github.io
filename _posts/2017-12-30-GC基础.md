---
layout: post
title:  GC基础
date:   2017-12-30 19:00:00 +0800
categories: jvm
tags: java jvm gc
published: false
---

## 前言

![GC基础](/assets/images/GC基础_1.jpg){:width="40%" hight="40%"}

Java和C++之间显著的一个区别就是对内存的管理。和C++把内存管理的权利赋予给开发人员的方式不同，Java拥有一套自动的内存回收系统（**Garbage Collection** ，**GC**）简称 **GC**，可以无需开发人员干预而对不再使用的内存进行回收管理。

垃圾回收技术（以下简称 **GC** ）是一套自动的内存管理机制。当计算机系统中的内存不再使用的时候，把这些空闲的内存空间释放出来重新投入使用，这种内存资源管理的机制就称为垃圾回收。

其实GC并不是Java的专利，GC的的发展历史远比Java来得久远的多。早在Lisp语言中，就有GC的功能，包括其他很多语言，如：Python（其实Python的历史也比Java早）也具有垃圾回收功能。
  
使用GC的好处，可以把这种容易犯错的行为让给计算机系统自己去管理，可以防止人为的错误。同时也把开发人员从内存管理的泥沼中解放出来。

虽然使用GC虽然有很多方便之处，但是如果不了解GC机制是如何运作的，那么当遇到问题的时候，我们将会很被动。所以有必要学习下Java虚拟机中的GC机制，这样我们才可以更好的利用这项技术。当遇到问题，比如内存泄露或内存溢出的时候，或者垃圾回收操作影响系统性能的时候，我们可以快速的定位问题，解决问题。

接下来，我们来看下JVM中的GC机制是怎么样的。

##  哪些内存可以回收

首先，我们如果要进行垃圾回收，那么我们必须先要识别出哪些是垃圾（被占用的无用内存资源）。

Java虚拟机将内存划分为多个区域，分别做不同的用途。简单的将，JVM对内存划分为这几个内存区域：
1. 程序计数器
2. 虚拟机栈
3. 本地方法栈
4. Java堆和方法区

其中 **程序计数器**、**虚拟机栈**、**本地方法栈** 是随着线程的生命周期出生和死亡的，所以这三块区域的内存在程序执行过程中是会有序的自动产生和回收的，我们可以不用关心它们的回收问题。剩下的Java堆和方法区，它们是JVM中所有线程共享的区域。由于程序执行路径的不确定性，这部分的内存分配和回收是动态进行的，GC主要关注这部分的内存的回收。 

有两种算法可以用于判断对像实例是否是存活的：一种是引用计数算法、还有一种是可达性分析。

### 引用计数

引用计数算法会对每个对象添加一个引用计数器，每当一个对象在别的地方被引用的时候，它的引用计数器就会加1；当引用失效的时候，它的引用计数器就会减1。如果一个对象的引用计数变成了0，那么表示这个对象没有被任何其他对象引用，那么就可以认为这个对象是一个死亡的对象（它占用的内存就是垃圾），这个对象就可以被GC安全地回收而不会导致系统出现问题。

我们可以发现，这种计数算法挺简单的。在C++中的智能指针，也是使用这种方式来跟踪对象引用的，来达到内存自动管理的。引用计数算法实现简单，而且判断高效，在大部分情况下是一个很好的垃圾标记算法。在Python中，就是采用这种方式来进行内存管理的。但是，这个算法存在一个明显的缺陷：如果两个对象之间有循环引用，那么这两个对象的引用计数将永远不会变成0，即使这两个对象没有被任何其他对象引用。

{% highlight java %}
public class ReferenceCountTest {

    public Object ref = null;

    public static void main(String ...args) {
        ReferenceCountTest objA = new ReferenceCountTest();
        ReferenceCountTest objB = new ReferenceCountTest();

        // 循环引用 objA <--> objB
        objA.ref = objB;
        objB.ref = objA;
        
        // 去除外部对这两个对象引用
        objA = null;
        objB = null;

        System.gc();
    }
}
{% endhighlight %}

上面的代码就演示了两个对象之间出现循环引用的情况。这个时候 **objA** 和 **objB** 的引用计数都是1，由于两个对象之间是循环引用的，所以它们的引用计数将一直是1，而即使这两个对象已经不再被系统所使用到。

由于引用计数这种算法存在这种缺陷，所以就有了一种称为“可达性分析算法”的算法来标记垃圾对象。
