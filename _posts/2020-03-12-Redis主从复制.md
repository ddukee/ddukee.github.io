---
layout: post
title: Redis主从复制
date: 2020-03-12 18:00:00 +0800
categories: redis
tags: redis replication
published: true
---

## 前言

Redis支持通过主从复制（master-slave）来实现数据库的横向扩展。通过Redis的`slaveof`命令（Redis 5.0 引入了`replicaof`命令代替`slaveof`命令），Redis可以为主服务器设置多个副本（replica，又称从服务器），副本通过复制主服务器的数据来实现数据的同步。副本可以为客户端提供读服务，分担主服务器的压力，以实现Redis数据库的横向扩展。

本文，我们就来聊聊Redis复制（Replication）功能的实现原理。

## 复制

![replication](/assets/images/redis主从复制_replication.png){:width="50%" hight="50%"}

Redis将数据库间的主从同步称为 **复制（Replication）** 。在副本上通过`slaveof`命令指定需要同步的主服务器的地址，然后该副本会将主服务器的数据同步到副本上。

{% highlight text %}
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:0
master_replid:e228e8aa8daa1821f04609df97f1ec04f707f664
master_replid2:c51c2505184d12aafdc138aa5616d8bc09a32f66
master_repl_offset:294
second_repl_offset:295
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:294
127.0.0.1:6379> slaveof 172.17.0.2 6379
OK
127.0.0.1:6379> info replication
# Replication
role:slave
master_host:172.17.0.2
master_port:6379
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_repl_offset:0
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c51c2505184d12aafdc138aa5616d8bc09a32f66
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:0

{% endhighlight %}

通过`info`命令我们可以看到执行完`slaveof 172.17.0.2 6379`命令以后，服务器的角色`role`变成了`slave`，同时`master_host`和`master_port`值变成了主服务器的IP地址和端口号。

我们可以通过`slaveof no one`将副本从复制模式中退出：

{% highlight text %}
127.0.0.1:6379> slaveof no one
OK
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:0
master_replid:e228e8aa8daa1821f04609df97f1ec04f707f664
master_replid2:c51c2505184d12aafdc138aa5616d8bc09a32f66
master_repl_offset:294
second_repl_offset:295
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:294
{% endhighlight %}

执行完`slaveof no one`命令以后，Redis服务器的角色变回了`master`。现在它又变成一个主服务器了。

下面，我们来看下Redis在`slaveof`命令背后做了哪些事情。

### 实现原理

Redis的复制功能主要分为两步：

1. 同步
2. 命令传播

### 同步

Redis复制的同步操作只要是将主服务器中的数据同步到副本上，使得副本的状态可以和主服务器一致。

当Redis服务器接收到`slaveof`命令以后，副本会向主服务器发送`SYNC`命令。主服务器在接收到`SYNC`命令以后会执行如下操作：

1. 接收到`slaveof`命令的主服务器会执行`BGSAVE`命令在后台创建一个RDB文件，同时还会创建一个命令缓冲区用于记录从创建RDB文件那一刻开始主服务器接收到的命令。
2. 当主服务器创建完RDB文件以后，主服务器会将创建的这个RDB文件发送给发起`SYNC`同步命令的副本。副本在接收到RDB文件后会将数据库的状态变成RDB文件快照中的数据库状态。
3. 最后，主服务器会将命令缓冲区中的命令发送给副本。完成以后副本的状态将和主服务器一致。

在执行完`SYNC`同步命令那一刻，副本和主服务器之间的状态处于一致状态。但是，由于主服务器一直在运行，同步完成那一刻保持的一致状态是临时的，往后随着主服务器不断接收到的新的更新命令，两边的数据库状态就不再保持一致了。为了让主从数据库可以一直保持一致状态，复制的第二步操作 **命令传播** 是必不可少的。

### 命令传播

由于同步操作只能保证短暂的数据库状态一致，在副本完成同步以后还需要将主服务器将接收到的写命令继续传递给副本。通过命令传播，副本的状态将一直跟随着主服务器的状态变化而变化。

命令传播阶段要求：当主服务器接收到导致数据库状态发生变更的命令以后，需要将这个写命令发送给所有复制该主服务器的副本。当副本接收到这个命令并执行以后，副本的状态将再次和主服务器的状态保持一致。

### 复制中断后恢复

前面我们介绍了Redis副本复制主服务器的过程。通过`SYNC`命令在首次复制的时候同步主服务器的状态，在同步完成以后通过命令传播机制增量的同步主服务器状态，保持副本和主服务器之前状态一致。

如果主服务器和副本之间网络正常，那么这种命令传播机制可以一直正常的运行下去，副本的状态将一直和主服务器保持一致。但是，一旦主服务器和副本之间出现网络问题导致复制被中断，副本的状态将不再和主服务器保持同步。当网络恢复，副本重新复制主服务器的时候，由于副本当前的状态是旧的状态，副本需要从主服务器的哪个状态开始同步就变成了一个问题。

在Redis 2.8版本以前，在复制中断以后副本为了和主服务器之间重新保持一致的状态，需要重新进行完整的复制过程：先通过`SYNC`命令进行同步，然后通过 **命令传播** 保持后续的状态一致。由于主服务器和副本之间没有记录标识复制状态的信息，即使副本和主服务器之间的同步只是短暂的断开，也需要重头开始复制。

复制过程需要消耗大量的服务器资源，比如生成RDB文件需要消耗磁盘的IO资源，传递快照文件需要消耗大量的网络IO资源。当复制被中断以后如果能快速恢复，那么副本的状态跟主服务器之间只相差了一部分写命令没有被同步，如果可以利用起来这个差异点，在恢复以后只同步副本缺少的命令，那么复制的效率将大大提高。

## 增量复制

为了解决旧版复制功能中复制中断恢复低效的问题，Redis从2.8版本开始引入了增量复制的机制。通过`PSYNC`命令代替`SYNC`命令来完成副本同步的工作。

`PSYNC`命令具有两种同步模式：

1. 完整重同步
2. 部分重同步

**完整重同步** 和`SYNC`命令一样，用于处理首次复制的情况。通过发送RDB文件完成副本和主服务器之间的状态同步。

**部分重同步** 模式则主要用于处理复制中断的场景。在复制过程被中断后，当网络恢复副本重新连接到主服务器以后，如果条件允许，主服务器将只会同步复制中断期间没有同步的命令，当副本接收到这些命令并执行以后，主服务器和副本之间的状态将再次保持一致。

为了实现`PSYNC`的增量同步功能，需要提供三部分信息才能完成增量同步过程：

1. 主服务器的复制偏移量和副本的复制偏移量（replication offset）
2. 主服务器的复制积压缓冲区（replication backlog）
3. 服务器运行ID（run ID）

### 复制偏移量

为了能够实现增量复制，在主服务器和副本中需要维护一个复制的偏移量以跟踪复制的进度。主服务器的复制偏移量记录了当前已经传播的写命令的数量，副本则记录当前已经接收到的写命令的数据。

主服务器通过比对副本的复制偏移量和主服务器自己的复制偏移量，就可以判断主服务器和副本之间是否处于一致的状态：

1. 如果复制偏移量相同，那么主服务器和副本之间就处于一致的状态。
2. 如果复制偏移量不同，那么主服务器和副本之间就处于不一致的状态。

有了复制偏移量以后，主服务器就可以通过对比两个偏移量得出主副本状态不一致的程度，以决定是通过增量复制还是全量复制来达到副本和主服务器的状态一致。为了达到这个目的，单单有复制偏移量是不够的，Redis还需要记录有多少命令被副本复制了。这就需要用到 **复制积压缓冲区** 技术。

### 复制积压缓冲区

Redis的主服务器维护了一个固定长度，默认的大小为1MB的先进先出队列（FIFO），Redis称之为 **复制积压缓冲区**。

当主服务器在进行命令传播的时候，它除了将命令发送给复制它的副本以外，还会将命令写入这个复制积压缓冲区。

![buffer](/assets/images/redis主从复制_buffer.png){:width="50%" hight="50%"}

主服务器的复制积压缓冲区包含了最近传播的命令，并且在为缓冲区中的每个字节记录了偏移量。当副本连接到主服务器的时候，副本通过`PSYNC`命令将自己的复制偏移量（offset）传递给主服务器，主服务器通过判断副本当前的偏移量和缓冲区中的偏移量来决定使用何种复制方式：

1. 如果副本落后于主服务器的数据依然在主服务器的复制积压缓冲区中，那么主服务器将采用增量复制将缓冲区的数据同步给副本。
2. 如果副本落后于主服务器的数据不在复制积压缓冲区中，那么主服务器会重新进行完整的同步。

### 服务器运行ID

为了实现增量复制，除了在服务器中记录复制的偏移量和复制缓冲区以外，我们还需要记录上一次复制的是哪个主服务器。因为增量复制中的增量概念是相对于某个主服务器而言的，所以脱离开被复制的主服务器是没有意义的。

Redis引入了服务运行ID来标识Redis服务器。每个Redis服务器都有一个运行ID，由40个随机字符组成，在服务器启动的时候自动生成。

当副本对主服务器进行初次复制的时候，主服务器会将自己的运行ID（run ID）传递给副本，副本会将这次复制的主服务器运行ID记录下来。当副本和主服务器断开并重连上一个主服务器以后，副本会告知连接上的主服务器之前保存的运行ID。主服务器通过如下逻辑判断采用何种同步方式：

1. 如果副本发送过来的运行ID和主服务器自己的运行ID相同，则表示重连的副本之前复制的是同一个主服务器，主服务器可以基于副本的复制偏移量来判断采用增量复制还是全量复制。
2. 如果副本发送过来的运行ID和主服务器的运行ID不同，则表示副本重连到了一个新的主服务器，主服务器需要进行完整的全量复制（如果副本传递过来的服务器ID是主服务器之前复制的旧的主服务器ID，那么仍旧可以进行增量复制。这种情况主要出现在集群的故障转移以后，集群中的从服务器被选举成为新的主服务器）。

### PSYNC命令

上面我们介绍了增量复制需要的三个部分，下面我们来看下支持增量复制的同步命令`PSYNC`的实现原理。

Redis的副本可以通过两种方式调用`PSYNC`命令来实现全量复制和增量复制：

1. 如果Redis服务器目前不属于任何一个服务器的副本，那么该服务器需要在进行初次复制的时候执行`PSYNC ? -1`来告知主服务器需要进行完整的复制。
2. 如果Redis服务器已经是某个服务器的副本，那么副本在进行增量复制的时候需要向主服务器发送`PSYNC <runID> <offset>`，这个命令告知主服务器上一次复制的主服务器ID和当前的复制偏移量。主服务器基于副本给出的这两个值判断采用哪种复制方式。

主服务器在接收到`PSYNC`命令以后，会基于当前情况返回三种返回值：

1. 如果主服务器需要和副本进行全量重同步，那么主服务器会返回`+FULLRESYNC <runID> <offset>`，其中`<runID>`是主服务器的运行ID，`<offset>`是主服务器的当前的复制偏移量。
2. 如果主服务器返回`+CONTINUE`，则表示主服务器和副本之间可以进行增量复制。
3. 如果主服务器返回`-ERR`，则表示主服务器的版本低于Redis 2.8，无法识别`PSYNC`命令。

### 故障转移后的增量复制

当主服务器宕机以后，故障转移机制会从集群的副本中选举了一个副本作为集群新的主服务器。在这种情况下，新选举的主服务器的ID将和原先的主服务器的服务器ID不同，为了在故障转移后可以正常进行增量复制，在Redis 4.0 版本中，新的主服务器可以识别之前复制旧的主服务器的副本，并继续进行增量复制：新的主服务器将会记录之前作为副本时复制的主服务器的ID和复制偏移量，当原先复制旧的主服务器的副本到新的主服务器上请求进行增量复制的时候，新的主服务器将在满足增量复制的条件下提供增量复制的功能。

### 重启后的增量复制

Redis 4.0 支持副本重启以后继续对主服务器进行增量复制。在副本开启`RDB`持久化以后，可以通过`SHUTDOWN`命令对Redis服务器进行优雅停机，Redis会把必要的信息保存在RDB文件中。当Redis服务器中从RDB文件中重启以后可以继续进行增量同步。Redis提供的这种特性使得在升级Redis服务器的是时候，可以在重启以后继续进行增量复制。

Redis不支持通过AOF文件进行重启后的增量同步，所以为了在升级服务器以后可以继续进行增量复制，我们可以在重启前将持久化机制改成RDB，在升级重启以后再启用AOF持久化。

## 心跳检测

前面我们提到Redis复制分为两个阶段：首先是数据同步，同步完成以后就会进入命令传播阶段，保证主服务器的状态变化可以实时的反应到副本。

Redis服务器在命令传播阶段默认会以每秒一次的频率向主服务器发送心跳检测命令：`REPLCONF ACK <offset>`。心跳的作用有三个：

1. 检测主服务器的网络连接状态
2. 辅助实现min-replicas选项
3. 检测命令丢失

### 检测网络连接

主服务器和副本之间通过发送和接收`REPLCONF ACK`命令来检查两者之间的网络连接是否正常，如果主服务器超过1秒没有收到来自副本的ACK命令，主服务器会认为和副本之间的连接出现了问题。

我们可以通过`INFO replication`命令在主服务器上查看副本的信息。在`lag`一行中记录了距上一次副本向主服务器发送`REPLCONF ACK`命令以来过了多少秒。正常情况下，`lag`的值在0和1之间跳动。如果这个值超过1秒，那么主服务器和副本之间的连接可能出现了问题。

{% highlight text %}
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=172.17.0.3,port=6379,state=online,offset=53872,lag=0 # lag记录了发送ACK的时间差
...
{% endhighlight %}

### min-replicas选项

Redis的`min-replicas-to-write`和`min-replicas-max-lag`这两个选项可以用于防止Redis的主服务器在不安全的情况下进行写操作，这两个选项控制了写操作需要满足的最少连接副本数和最大连接延迟时间（lag值），这两个值的统计都是基于心跳检测来实现的。关于`min-replicas-*`的这两个选项值的作用，可以参考下面的 **安全写入** 一节。

### 检测命令丢失

在副本发送给主服务器的`REPLCONF ACK offset`命令中包含了复制的偏移量。当故障原因导致主服务器传播到副本的命令没有正确被副本接收，主服务器通过副本在发送心跳报文的时候带上的复制偏移量，判断复制偏移量在复制积压缓冲区中的位置，主服务器可以将副本缺少的那部分命令数据重新发送给副本，实现命令丢失的检测。

主服务器在命令丢失检测中发送的命令的过程和增量复制中发送命令数据的过程有些类似，区别在于：命令检测的命令数据同步是在主副本之间连接正常的情况下进行的，而增量复制是在副本连接中断恢复后进行的。

*注意：由于增量复制是Redis 2.8版本以后新增的，所以命令丢失的检测的功能也只在Redis 2.8以后才有。*

## 安全写入

从Redis 2.8 开始，Redis服务器支持安全地写入命令。通过配置，只有在至少有N个副本连接到主服务器的情况下，主服务器才允许写入命令。通过配置`min-replicas-to-write`和`min-replicas-max-lag`这两个选项来控制命令写入的安全级别：

+ min-replicas-to-write <number of replicas>
+ min-replicas-max-lag <number of seconds>

下面的配置表示：当且仅当有至少N个副本集在线，并且最大延迟时间低于M秒的情况下，才允许执行写入命令。

{% highlight text %}
min-replicas-to-write N
min-replicas-max-lag M
{% endhighlight %}

由于复制过程是异步进行的，在命令传播到各个副本的过程中可能会导致命令丢失。而通过配置`min-replicas-to-write`和`min-replicas-max-lag`这两个选项，可以将命令丢失的时间窗口变的可控，在一定程度上保证了写入的数据安全性。

## 只读副本

Redis服务器从 2.6 版本开始支持只读副本模式。副本默认以只读模式运行，可以在`redis.conf`配置文件中设置`replica-read-only`选项进行配置，也可以在运行时通过`CONFIG SET`命令进行设置。

{% highlight text %}
127.0.0.1:6379> set key1 "key1"
(error) READONLY You can't write against a read only replica.

# 关闭只读模式
127.0.0.1:6379> config set replica-read-only no
OK
127.0.0.1:6379> set key1 "key1"
OK
{% endhighlight %}

正常情况下副本的数据变化只来自于对主服务器的复制，所以副本一般运行在只读模式下。Redis也支持在副本中关闭只读模式，在这种情况下，副本可以接受写命令，但是一旦副本重新启动或者和主服务器之间进行重新同步，那么之前写入到副本的数据就会被主服务器同步过来的数据覆盖。因此在副本上执行写命令只能用于有限的使用场景，比如对临时数据的存储。

*注意：在可写的副本上执行`EXPIRE`命令时需要格外注意。在 Redis 4.0 版本之前，在副本中执行的 `EXPIRE`命令将不会被正确执行，即使键已经超时不能被读取，该数据仍旧在副本中，仍旧占用副本内存空间，这会导致键泄露。*

## 级联

Redis的副本除了可以直接复制主服务器之外，副本也可以复制别的副本。当副本复制别的副本的时候，原先多个副本复制同一个主服务器的复制拓扑结构就变成了级联复制的方式。由于复制过程需要消耗主服务器的IO资源，级联服务器可以将这部分消耗从主服务器转移给各个副本，提高了主服务器复制的性能。

下面是一个案例，有三台Redis服务器：`172.17.0.2`、`172.17.0.3`和`172.17.0.4`，通过级联方式进行复制配置：

![cascade_repilcation](/assets/images/redis主从复制_cascade.png){:width="60%" hight="60%"}

通过`info replication`命令可以查看服务器的复制状态：

{% highlight text %}
# 172.17.0.2
127.0.0.1:6379> info replication
role:master
connected_slaves:1
slave0:ip=172.17.0.3,port=6379,state=online,offset=117643,lag=1
master_replid:7a6e0ec9784b777d61aa09f3ef12a01158c85abd
master_replid2:4c77ff8a8aad58c0525719a03a5691831caf76e3
master_repl_offset:117643
second_repl_offset:117251
...

# 172.17.0.3
127.0.0.1:6379> slaveof 172.17.0.2 6379
OK
127.0.0.1:6379> info replication
role:slave
master_host:172.17.0.2
master_port:6379
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_repl_offset:117629
slave_priority:100
slave_read_only:0
connected_slaves:1
slave0:ip=172.17.0.4,port=6379,state=online,offset=117629,lag=1
master_replid:7a6e0ec9784b777d61aa09f3ef12a01158c85abd

# 172.17.0.4
127.0.0.1:6379> slaveof 172.17.0.3 6379
OK
127.0.0.1:6379> info replication
role:slave
master_host:172.17.0.3
master_port:6379
master_link_status:up
master_last_io_seconds_ago:4
master_sync_in_progress:0
slave_repl_offset:118387
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:7a6e0ec9784b777d61aa09f3ef12a01158c85abd
{% endhighlight %}

### 可写副本

我们在上一节中提到了Redis可以支持写副本的操作，这种情况下写命令产生的结果只会影响本地的数据库状态。当通过级联方式进行复制的时候，从Redis
 4.0 开始，副本本地写的结果不会传递到复制它的副本，所有副本都只能同步来自主服务器的数据。

## 复制和持久化相互作用存在的隐患

在配置复制的时候需要格外小心一个场景：如果主服务器没有配置持久化，但是又有副本对该主服务器进行复制。当主服务器自动重启以后，由于重启的主服务器没有持久化配置，启动以后将是一个空的数据库。这种情况下复制该主服务器的副本都会因为复制到空的主服务器而导致副本上的数据也被清空。下面是一个案例：

1. 关闭了持久化配置的主服务器A，副本B和C复制主服务器A。
2. 服务A因为某些原因自动重启，由于持久化被关闭，重启后的Redis服务器A由于没有启用持久化，导致重启后变成了空数据库。
3. 副本B和C将继续从A服务器复制数据，由于A现在的数据库是空的，这将导致B和C清空自己数据库的数据，和主服务器一样变成空的数据库。

当数据的安全性很重要的时候，如果主服务器的持久化功能没有打开，那么需要将自动重启功能关闭，防止出现主服务器重启以后整个Redis副本数据也丢失的情况。

## 复制和键超时时间

Redis支持对键设置超时时间，通过服务器在后台进行计时来控制键是否超时。当设置了超时的键被复制到副本上的时候，副本需要正确处理键超时的问题。为了让副本可以正确的对超时的键进行计时，一种方案是在主副本之间进行时钟同步，但是副本复制的方式导致服务器之间连接关系变的复杂（比如级联复制），时钟同步方案难以实现。

Redis为了保证键可以正确超时，采用了如下方式：

1. 从服务不主动淘汰超时的键，而是等待主服务器淘汰超时的键以后将`DEL`命令同步给副本。
2. 由于主服务器同步`DEL`命令不是实时的（复制是异步进行的），导致被淘汰的键可能还短暂的遗留在副本中。为了处理这种情况，副本本地还会维护一个计时器对键进行超时计时，当本地超时时间到了以后该键就不能被读取了。但是该键仍旧在副本的数据库中，等待从主服务器同步的`DEL`命令将它删除。
3. 在执行Lua脚本期间不进行键淘汰。由于Redis服务器通过单线程执行命令，在执行Lua脚本过程中主服务器会阻塞。这就保证了一个键要么在执行Lua脚本前失效，要么在执行Lua脚本后失效，使得在执行Lua过程中不会出现键失效的情况，这可以保证副本在执行脚本的时候具有一致的效果（体现在命令传播上就是：`DEL`命令的传播要么在执行Lua脚本的命令之前，要么在脚本执行之后，这保证了副本和主服务器在执行的时候有相同的数据库状态）。

## 总结

在本文中，我们介绍了Redis复制的概念和原理。介绍了Redis旧的复制机制和改进的增量复制机制；重点介绍了增量复制的实现原理和优势；介绍了复制的另外一种拓扑形式：级联复制；分析了持久化和复制一起使用时可能导致的数据安全性隐患。最后我们介绍了Redis副本如何处理超时的键数据。

